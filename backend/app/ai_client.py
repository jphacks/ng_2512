"""Lightweight client helpers for interacting with the AI compute service."""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Iterable, List, Optional, Sequence
from urllib import error, request
from urllib.parse import urljoin

from .config import AI_COMPUTE_SERVER_URL, AI_COMPUTE_TIMEOUT

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class FaceEmbeddingResult:
    """Response payload for a single detected face embedding."""

    embedding: List[float]
    bbox: Optional[dict[str, Any]] = None


@dataclass(frozen=True)
class FaceMatchResult:
    """Face matching result from the AI service."""

    user_id: int
    score: float


@dataclass(frozen=True)
class ProposalSuggestion:
    """Proposal suggestion generated by the AI service."""

    title: str
    event_date: datetime
    location: Optional[str]
    participant_ids: List[int]
    source: str = "model"


def _json_default(value: Any) -> Any:
    if isinstance(value, datetime):
        return value.isoformat()
    raise TypeError(f"Object of type {type(value).__name__} is not JSON serializable")


def _post_json(path: str, payload: Any) -> Optional[dict[str, Any]]:
    base_url = AI_COMPUTE_SERVER_URL
    if not base_url:
        logger.debug("AI_COMPUTE_SERVER_URL is not configured; skipping request to %s", path)
        return None

    endpoint = urljoin(base_url.rstrip("/") + "/", path.lstrip("/"))
    try:
        data = json.dumps(payload, default=_json_default).encode("utf-8")
    except TypeError as exc:
        logger.warning("Failed to encode payload for %s: %s", endpoint, exc, exc_info=False)
        return None

    request_obj = request.Request(
        endpoint,
        data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )

    try:
        with request.urlopen(request_obj, timeout=AI_COMPUTE_TIMEOUT) as response:
            raw_body = response.read()
    except error.URLError as exc:
        logger.warning("Failed request to %s: %s", endpoint, exc, exc_info=False)
        return None

    if not raw_body:
        logger.warning("Empty response received from AI compute server for %s", endpoint)
        return None

    try:
        decoded = json.loads(raw_body.decode("utf-8"))
    except json.JSONDecodeError:
        logger.warning("Invalid JSON received from AI compute server for %s", endpoint)
        return None

    if not isinstance(decoded, dict):
        logger.warning("Unexpected payload structure from %s", endpoint)
        return None

    return decoded


def _coerce_floats(raw: Any) -> Optional[List[float]]:
    if not isinstance(raw, (list, tuple)):
        return None
    vector: List[float] = []
    for value in raw:
        try:
            vector.append(float(value))
        except (TypeError, ValueError):
            return None
    return vector


def _parse_datetime(value: Any) -> Optional[datetime]:
    if isinstance(value, datetime):
        return value
    if isinstance(value, str):
        try:
            return datetime.fromisoformat(value)
        except ValueError:
            return None
    return None


def _iter_face_payload(payload: Any) -> Iterable[dict[str, Any]]:
    if isinstance(payload, dict):
        faces = payload.get("faces")
        if isinstance(faces, list):
            yield from (item for item in faces if isinstance(item, dict))
        else:
            yield payload
    elif isinstance(payload, list):
        yield from (item for item in payload if isinstance(item, dict))


def fetch_face_embeddings(storage_key: str) -> List[FaceEmbeddingResult]:
    """Request face embeddings for the given storage key from the AI service."""
    if not storage_key:
        return []

    payload = _post_json("api/face_embeddings", {"storage_key": storage_key})
    if not payload:
        return []

    results: List[FaceEmbeddingResult] = []
    for item in _iter_face_payload(payload):
        embedding = _coerce_floats(
            item.get("embedding") if "embedding" in item else item.get("vector")
        )
        if embedding is None:
            continue
        bbox = item.get("bbox")
        if bbox is not None and not isinstance(bbox, dict):
            bbox = None
        results.append(FaceEmbeddingResult(embedding=embedding, bbox=bbox))

    return results


def generate_proposal_suggestion(context: dict[str, Any]) -> Optional[ProposalSuggestion]:
    """Ask the AI service to generate a proposal suggestion."""
    response = _post_json("api/proposals/suggest", context)
    if not response:
        return None

    title = response.get("title")
    event_date = _parse_datetime(response.get("event_date"))
    participant_ids_raw = response.get("participant_ids")

    if not title or event_date is None:
        logger.warning("Incomplete proposal suggestion received: %s", response)
        return None

    participants: List[int] = []
    if isinstance(participant_ids_raw, (list, tuple)):
        for value in participant_ids_raw:
            try:
                participants.append(int(value))
            except (TypeError, ValueError):
                continue

    location = response.get("location")
    if location is not None and not isinstance(location, str):
        location = None

    source = response.get("source") if isinstance(response.get("source"), str) else "model"

    return ProposalSuggestion(
        title=str(title),
        event_date=event_date,
        location=location,
        participant_ids=participants,
        source=source,
    )


def match_faces(
    *,
    storage_key: str | None,
    embedding: Sequence[float] | None,
    candidates: Iterable[dict[str, Any]],
    top_k: int | None = None,
    min_score: float | None = None,
) -> List[FaceMatchResult]:
    """Request face match scores for the provided candidates."""
    candidate_payload: List[dict[str, Any]] = []
    for item in candidates:
        user_id = item.get("user_id")
        vector = _coerce_floats(item.get("embedding"))
        if vector is None:
            continue
        try:
            user_id_int = int(user_id)
        except (TypeError, ValueError):
            continue
        candidate_payload.append({"user_id": user_id_int, "embedding": vector})

    if not candidate_payload:
        return []

    request_payload: dict[str, Any] = {"candidates": candidate_payload}
    if storage_key:
        request_payload["storage_key"] = storage_key
    if embedding is not None:
        vector = _coerce_floats(embedding)
        if vector is not None:
            request_payload["embedding"] = vector
    if top_k is not None:
        request_payload["top_k"] = int(top_k)
    if min_score is not None:
        request_payload["min_score"] = float(min_score)

    response = _post_json("api/face_match", request_payload)
    if not response:
        return []

    matches_raw = response.get("matches")
    if not isinstance(matches_raw, list):
        return []

    results: List[FaceMatchResult] = []
    for entry in matches_raw:
        if not isinstance(entry, dict):
            continue
        try:
            user_id = int(entry.get("user_id"))
            score = float(entry.get("score"))
        except (TypeError, ValueError):
            continue
        results.append(FaceMatchResult(user_id=user_id, score=score))

    return results
